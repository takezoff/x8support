# ラケットの表示と操作

## 画面に図形を表示する

以下のコードと実行結果を見てください。

```
x8.rect(40, 50, 70, 60, 9)
```

♪矩形表示

`x8.rect(x0,y0,x1,y1[,col])`は、画面に四角形や正方形（**矩形**）を描画する関数です。矩形の左上の座標を`x0,y0`で、右下の座標を`x1,y1`で、色を`col`で指定します。`col`は省略できます。

**矩形は`x1,y1`の座標を含むため、この場合の幅は、`30`ではなく`31`であることに注意してください。**高さについても同様です。

Note: このように関数呼び出しの形を説明する際、対応する角括弧`[ ]`で囲まれた部分は、その部分を一括して省略できることを表しています。例えば、`x8.fntscale([sclx[,scly]])`の場合、`scly`または、`sclx,scly`を省略することはできますが、`sclx`だけを省略することはできないことに注意してください。

このゲームでは、ラケット、ボール、ブロックをすべて、`x8.rect`を使って表示しています。

## ラケットを動かす

以下のコードと実行結果を見てください。

```
x = 32
y = 108
w = 24
h = 4
v = 2

while true do
   -- Move
   if x8.btnprs(0) then -- ←
      x = x - v
   elseif x8.btnprs(1) then -- →
      x = x + v
   end
   -- Draw
   x8.cls()
   x8.rect(x, y, x + w - 1, y + h - 1)
   -- Next frame
   x8.wait()
end
```

♪ラケットの動き

これは、ラケットを表示して`←`と`→`のボタンで動かすだけのコードです。ラケットが画面外に出てしまいますが今は気にしません。

`elseif`は`if`文の制御構造の一部です。既に紹介した`if`文ですが、本当はこんな形をしています。

> `if` 式 `then` ブロック {`elseif` 式 `then` ブロック} [`else` ブロック] `end`

**式**の結果が真なら**`then`ブロック**を実行し、偽なら**`else`ブロック**を実行します。偽の場合`elseif`でさらに制御を分けることができます。

式の結果について、`false`と`nil`は偽とみなされ、それ以外のすべての値（`0`や空文字列`""`なども）は真とみなされます。

```
a = 0
if a == 0 then
    a = 1           -- ここに来る
end
if a == 0 then
    a = 100         -- ここには来ない
elseif a == 1 then
    a = 101         -- ここに来る
else
    a = 102         -- ここには来ない
end
x = a               -- x:101
```

`x8.btnprs`は、現フレームでボタンが押されているかどうかの情報を返します。`x8.btnprs(0)`の場合、現フレームで`←`ボタンが押されていれば`true`、押されていなければ`false`を返します。`x8.btnprs(1)`は`→`ボタンの情報を返します。

変数`x`、`y`はラケット矩形の座標、`w`、`h`はラケット矩形の幅と高さです。**変数`v`は1フレームあたりの移動量です。**

Hint: このコードでは`y`や`v`など、コード中で変更されることがない数値も、コードの先頭で変数に入れています。こうしておくと、ただの数値より意味が分かりやすいし、後で数値を変更したくなっても1箇所の変更で済みます。

結局このコードは、以下のような意味になります。

```
while true do
   -- Move
   `←`が押されていたら
      `x`座標を`v`だけ左にずらす
   でなければ、`→`が押されていたら
      `x`座標を`v`だけ右にずらす
   -- Draw
   画面をクリアする
   ラケットを座標`x,y`に表示する
   -- Next frame
   フレームを更新する
end
```

フレーム更新を含む無限ループなので、ループ内の処理は1/30秒毎に1回（毎秒30回）実行されます。今回の入力によってラケット位置を少しずらし、前回描いた画面をクリアして、新しい位置にラケットを描く、ということを毎フレーム繰り返しています。

Hint: このように、短い時間毎の処理を高速で繰り返すことで、連続して動いているように見せるのが、リアルタイムっぽいゲームの基本的な作り方です。

## ラケットの完全な動き

以下のコードを見てください。

```
SCREEN_W = 128
x = 32
y = 108
w = 24
h = 4

while true do
   -- Move
   local v = 2.0
   if x8.btnprs(4) or x8.btnprs(5) then -- Ⓐ or Ⓑ
      v = v * 3.0
   end
   if x8.btnprs(0) then -- ←
      x = x - v
   elseif x8.btnprs(1) then -- →
      x = x + v
   end
   if x < 0 then
      x = 0
   elseif (x + w) > SCREEN_W then
      x = SCREEN_W - w
   end
   -- Draw
   x8.cls()
   x8.rect(x, y, x + w - 1, y + h - 1)
   -- Next frame
   x8.wait()
end
```

これは、ラケット表示と操作の完全なコードです。新しいことがいくつか出てきたので、先にそれらを説明します。

### 演算子と式

`if`文の**式**に出てくる`or`、`<`、`>`のことを**演算子**といいます。

**演算**とは計算することをいいます。**演算子**とは演算を表す記号のことで、いくつかの引数を取って1つの値を返します。今まで出てきた`+`、`-`、`*`なども**算術演算子**という演算子です。

**式**に書かれた演算や関数呼び出しなどが実行されることを、式が**評価**されるといいます。式は評価されると、結果として必ず値になります。逆にいうと、実行結果が値にならないコードを式の部分に書くことはできません。

### 算術演算子

**算術演算子**は普通の数値計算を行う演算子のことで、以下のものがあります。

- `+` : 加算
- `-` : 減算
- `*` : 乗算
- `/` : 浮動小数点数除算（小数部もちゃんと計算されます）
- `//` : 切り捨て除算（結果の小数部は切り捨てられます）
- `%` : 剰余
- `^` : 累乗
- `-` : 単項マイナス（独立した`-3`とかのマイナス）

例えば評価結果`x`は以下のようになります。

```
x = 3 ^ 3       -- x:27
x = 3.6 ^ 2.4   -- x:21.633460842026
x = 9 / 4       -- x:2.25
x = 9 / 2.5     -- x:3.6
x = 9 // 4      -- x:2
x = 9.3 // 4    -- x:2.0
x = 9 % 4       -- x:1
x = 9 % 4.3     -- x:0.4
```

### 関係演算子

`<`と`>`は**関係演算子**といい、記号を挟んで左右2つの引数を取り、記号の意味する関係になっているかどうかを、`true`か`false`で返します。関係演算子には以下のものがあります。

- `==` : 左の値と右の値が等しい
- `~=` : 左の値と右の値が等しくない
- `<` : 左の値が右の値より小さい
- `>` : 左の値が右の値より大きい
- `<=` : 左の値が右の値より小さい、または等しい
- `>=` : 左の値が右の値より大きい、または等しい

```
x = 3 == 3      -- x:true
x = 3 ~= 3      -- x:false
x = 5 < 8       -- x:true
x = "6" == 6    -- x:false
```

### 論理演算子

`if`文の式に出てくる`or`は**論理演算子**といいます。論理演算子には`and`、`or`、`not`があります。

- `not` : 右の引数の真偽を反転して、結果を`true`か`false`で返します。**引数が真なら結果は偽、引数が偽なら結果は真になります。**
- `and` : 左の引数が`false`か`nil`であればその引数を返し、そうでなければ右の引数を返します。**引数が両方とも真なら結果は真、それ以外なら結果は偽になります。**
- `or` : 左の引数が`nil`でも`false`でもなければその引数を返し、そうでなければ右の引数を返します。**引数のどちらか一方でも真なら結果は真、それ以外なら結果は偽になります。**

Hint: `and`と`or`の動作がややこしいですが、`if`文や`while`文などの**条件式**で使われた場合は、**引数の真偽と結果の真偽の関係**だけに注目すれば大丈夫です。

```
x = not 10              -- x:false
x = not nil             -- x:true
x = 10 or 20            -- x:10
x = nil or "a"          -- x:"a"
x = nil and 10          -- x:nil
x = false and nil       -- x:false
x = false or nil        -- x:nil
x = 10 and 20           -- x:20
```

### 演算子の優先順位

複数の演算が並んだ場合、どの演算を先に行うかについては、演算子の[優先順位]()で決まります。
今まで出てきた演算子の優先順位は以下のとおりです。より上にあるほど先に演算されます。

- `^`
- `not` `-`(単項マイナス)
- `*` `/` `//` `%`
- `+` `-`
- `<` `>` `<=` `>=` `~=` `==`
- `and`
- `or`

普通の数式と同じように、括弧`( )`を使って式の優先度を変えることができます。

Hint: 演算子の優先順位に不安があるときは、気軽に括弧`( )`を使っちゃいましょう。あとから見返したときにもわかりやすいです。

### コードの説明

コードを見ていく準備が整いました。最初のコードはこうでした。

```
SCREEN_W = 128
x = 32
y = 108
w = 24
h = 4

while true do
   -- Move
   local v = 2.0
   if x8.btnprs(4) or x8.btnprs(5) then -- Ⓐ or Ⓑ
      v = v * 3.0
   end
   if x8.btnprs(0) then -- ←
      x = x - v
   elseif x8.btnprs(1) then -- →
      x = x + v
   end
   if x < 0 then
      x = 0
   elseif (x + w) > SCREEN_W then
      x = SCREEN_W - w
   end
   -- Draw
   x8.cls()
   x8.rect(x, y, x + w - 1, y + h - 1)
   -- Next frame
   x8.wait()
end
```

これは、[ラケットを動かす](#ラケットを動かす) で説明したコードに、2つの部分が追加されたものです。

1つ目は、入力によるラケット移動の直前にある、この部分です。

```
   local v = 2.0
   if x8.btnprs(4) or x8.btnprs(5) then -- Ⓐ or Ⓑ
      v = v * 3.0
   end
```

ループ開始時に毎回`v`を`2.0`に設定してから、もし`Ⓐ`か`Ⓑ`のボタンが押されていたら、`v`を`3.0`倍にしています。

これは、`Ⓐ`か`Ⓑ`を押しながらラケットを操作した場合、ラケットの動きを速くする処理です。ループ開始時に速度をリセットすることで、加速し続けないようにしています。

2つ目は、入力によるラケット移動の直後にある、この部分です。

```
   if x < 0 then
      x = 0
   elseif (x + w) > SCREEN_W then
      x = SCREEN_W - w
   end
```

これは、直前の移動でラケットが画面からはみ出たら、画面内に戻す処理です。

♪位置強制の図

これでラケットの表示と操作についてはおしまいです。次行きましょー！！
