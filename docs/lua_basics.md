# <img src="imgs/lua/Lua-Logo_128x128.png" width="50"> Lua 5.3 クイックリファレンス

## はじめに

このドキュメントは **Lua 5.3 リファレンスマニュアル** を元に、これからプログラミングを始める人にも使いやすくするため、以下の方針でまとめたものです。

- プログラミングに必須の基本的な部分だけに記載し、それ以外のより高度な部分や応用的な部分は省略しました。
- 正確さや完全さよりも、わかりやすさを心がけました。
- **x8studio**でのプログラミングで利用出来ない部分は省略しました。

このドキュメントで省略したのは主に以下の部分です。

- 環境とグローバル環境
- エラー処理
- メタテーブルとメタメソッド
- ガベージコレクション
- コルーチン
- 文の構文的な詳細
- チャンク
- メソッド関連などいくつかのシンタックスシュガー
- 可変長引数
- Luaの組み込みに関すること全般
- Luaでのプログラミングに直接には関係がないこと全般
- 標準ライブラリの詳細（これは [Lua 5.3 標準ライブラリ](lua_stdlib.md) を参照）
- Luaの完全な構文

より詳しく知りたい場合は、このドキュメントの元になっている [Lua 5.3 リファレンスマニュアル](http://milkpot.sakura.ne.jp/lua/lua53_manual_ja.html) （外部リンク、ボランティアさんによる非公式の日本語訳）に説明があります。
公式のドキュメントは [Lua 5.3 Reference Manual](https://www.lua.org/manual/5.3/) （外部リンク、英語）です。

---

## Lua

Luaは、パワフルで効率的、軽量、埋め込み可能なスクリプト言語です。手続き型プログラミング、オブジェクト指向プログラミング、関数型プログラミング、データ駆動型プログラミング、データ記述をサポートしています。

## 値と型

Luaの全ての**値**（`32`、`"foo"`、`true`など）は、それ自身が**型**（とり得る値の種類）を持っています。
Luaの全ての値は**変数**（値を格納する場所）に格納することができ、他の関数に渡すことができ、戻り値として返すことができます。
Luaには以下の８つの基本型があります。

- nil
- ブーリアン
- 数値
- 文字列
- 関数
- ユーザーデータ
- スレッド
- テーブル

標準ライブラリ関数 [type](lua_stdlib.md#基本機能) を使うと値の型を表す文字列を取得できます。
ユーザーデータを除き、型には**値**を保持するものと**参照**を保持するものがあります。

### 値を保持する型

値を保持する型について代入、引数渡し、戻り値受け取りを行うと、値がコピーされて渡されます。
**渡された値を変更しても渡した側の値に影響はありません。**

#### nil

値を保持します。
値は`nil`だけです。通常は値が無いことを表します。

#### ブーリアン

値を保持します。
値は`false`と`true`だけです。
**条件判断においては`nil`と`false`は偽であり、それ以外の値（`0`や空文字列`""`なども）は全て真です。**

#### 数値

値を保持します。
整数と実数（小数部を含む数値）の両方を表します。両者は必要に応じて自動的に[変換](#強制型変換)されます。

#### 文字列

値を保持します。
ゼロ（`'\0'`）を含む不変のバイト（8ビットの値）列です。

### 参照を保持する型

参照を保持する型について代入、引数渡し、戻り値受け取りを行うと、値はコピーされず、同じ値への参照（紐付けられたタグのようなもの）が渡されます。
**渡された値（参照先）を変更すると渡した側の値も変更されます。**

#### 関数

参照を保持します。
呼び出すことができるひとまとまりのプログラムです。いくつかの値を渡したり（引数）返したり（戻り値）することも出来ます。

#### スレッド

参照を保持します。
コルーチンを実装するために使われます。OSのスレッドとは無関係です。

#### テーブル

参照を保持します。
Luaで唯一のデータを構造化する仕組みです。`nil`以外のあらゆる値をインデックス（キー）として使える配列（**連想配列**）で、`nil`以外のあらゆる値を異種混合で格納できます。
[テーブルを作成する便利な方法](#テーブルコンストラクタ)がいくつかあります。
テーブルを**[シーケンス](#長さ演算子)**にすることで通常の配列（インデックスは`1`始まり）のように使うことが出来ます。

### その他の型

#### ユーザーデータ

ユーザーデータ型はLuaのデータではないデータを格納する型です。ユーザーデータには等値比較以外の演算はなく、値をLuaで作成したり変更することはできません。

---

## 字句

字句要素 (**トークン**) 間の空白 (改行を含む) は無視されます (ただし名前やキーワードを区切る効果はあります)。
変数や関数などにつける名前 (**識別子**) にはアルファベット、数字、アンダースコア`_`を使えますが数字で始まってはいけません。
以下のキーワードは予約されており、 名前として使うことはできません。
```
and       break     do        else      elseif    end
false     for       function  goto      if        in
local     nil       not       or        repeat    return
then      true      until     while
```
大文字と小文字は区別されます。and は予約語ですが、 And と AND は2つの異なる有効な名前です。
**アンダースコアと大文字で始まる名前 (例えば _VERSION) を作るのは避けるようにしてください。**
以下の文字列は、それ以外のトークンです。
```
+     -     *     /     %     ^     #
&     ~     |     <<    >>    //
==    ~=    <=    >=    <     >     =
(     )     {     }     [     ]     ::
;     :     ,     .     ..    ...
```
文字列を直接記述（**リテラル**）するにはシングルクォート`'`またはダブルクォート`"`で囲みます。また例えば以下のような、文字列内で特別な意味を持つ記述（**エスケープシーケンス**）も使えます。

- `\n` : 改行を表す
- `\\` : 文字としてのバックスラッシュ`\`を表す
- `\"` : 文字としてのダブルクォート`"`を表す
- `\'` : 文字としてのシングルクォート`'`を表す
- `\ddd` : 最大3桁の10進数dddで1文字（1バイト）を表す
- `\xXX` : ちょうど2桁の16進数XXで1文字（1バイト）を表す

リテラル文字列は**長括弧**`[[`〜`]]`や`[==[`〜`]==]`で囲んで記述することもできます。`=`の数（**段数**）はいくつでもよく、同じ段数の閉じ長括弧までが文字列になります。この形式ではリテラルを複数行に渡って書くことができ、いかなるエスケープシーケンスも解釈せず、改行は単純な改行に変換されます。また、便利なように開き長括弧の直後の改行は文字列に含まれません。以下は全て同じ文字列を表します。
```
a = 'alo\n123"'
a = "alo\n123\""
a = '\97lo\10\04923"'
a = [[alo
123"]]
a = [==[
alo
123"]==]
```
単純に整数や実数を記述すると10進数の数値リテラルとして解釈されます。`0x`または`0X`につづけて記述すると16進数の数値リテラルとして解釈されます。16進数は一桁を`0 1 2 3 4 5 6 7 8 9 a b c d e f`（大文字でも有効）で表します。
```
3   345   0xff   0XBEBADA   700.0   3.1415
```
プログラムとして解釈されない**コメント**を記述することができます。2つのハイフン`--`から行末までがコメントになります。また`--`の直後を長括弧（`[[`〜`]]`や`[==[`〜`]==]`）にすると、その囲まれた部分をコメントにできます。
```
-- ここはコメントです
foo = 123 + 456 -- ここはコメントです
--[[
    ここは全て
    コメントです
]]
--[==[
    ここは全て
    コメントです
]==]
```

---

## 変数

**変数**は値を格納する場所です。[識別子](#字句)で表され、以下の3つの種類があります。

- グローバル変数
- ローカル変数
- テーブルフィールド

テーブルフィールド以外は`local`で[ローカル宣言](#ローカル宣言)しないかぎり**グローバル変数**（どこからでもアクセス出来る変数）になります。ローカル変数は、その[スコープ](#可視性ルール)内部で定義された関数から自由にアクセスできます。
変数に最初の代入が行われるまで値は`nil`です。
角括弧はテーブルのインデックス検索に使われ、`var[3]`や`var["name"]`でテーブル`var`のフィールドにアクセスできます。また`var["name"]`は`var.name`と記述することもできます。
```
a = 123         -- a はグローバル変数
local b = 456   -- b はローカル変数
t = {}
t["foo"] = 123  -- テーブル t のフィールド foo にアクセス
t.bar = t.foo   -- t.bar:123
```

---

## 文

代入、制御構文（`if`や`while`など）、関数呼び出し、変数宣言などのプログラムを構成する要素を**文**と言います。

### ブロック

一連の文をまとめたものを**ブロック**と言います。制御構造の一部としても使われますが、

**`do` ブロック `end`**

を使って自由に作ることものできます。
```
do              -- ブロックの開始
    a = 0
    a = a + 1
    x = a
end             -- ブロックの終了
```
ブロックは変数宣言の[スコープ](#可視性ルール)を制御したり、他のブロックの途中に [return](#return) 文を追加するために使われることもあります。

### 代入

変数に値を入れる（または参照を紐付ける）ことを**代入**と言います。`=`を挟んで**左辺**の変数に**右辺**の値（または[式](#式)の結果）を入れます。左辺も右辺もカンマ`,`区切りで複数指定でき、右辺の数が足りない場合は`nil`が設定されます。
```
x = 0               -- x:0
x, y, z = 1         -- x:1, y:nil, z:nil
x = 1, 2, 3         -- x:1
x, y, z = 1, 2, 3   -- x:1, y:2, z:3
```

### 制御構造

通常、プログラムは記述された順に制御が進みますが、この流れを変化させる仕組みを**制御構造**といいます。`if` `while` `repeat` `goto` `break` `return` などの**制御構文**で構成されます。また2種類の`for`文（[数値for](#数値for)、[汎用for](#汎用for)）もあります。
以降、文の書き方の説明に出てくる中括弧で囲まれた部分 **{a}** と角括弧で囲まれた部分 **[a]** は、それぞれ以下のようなことを表します。

- **{a}** は **{a}** の部分が何回連続してもよく、また無くてもよい。
- **[a]** は **[a]** の部分があってもなくてもよい。

#### if

**`if` 式 `then` ブロック {`elseif` 式 `then` ブロック} [`else` ブロック] `end`**

**式**の結果が真になるか偽になるかで制御を分けます。結果が真なら**`then`ブロック**を実行し、偽なら**`else`ブロック**を実行します。偽の場合`elseif`でさらに制御を分けることができます。
式の結果について、`false`と`nil`は偽とみなされ、それ以外のすべての値（`0`や空文字列`""`なども）は真とみなされます。
```
a = 0
if a == 0 then
    a = 1           -- ここに来る
end
if a == 0 then
    a = 100         -- ここには来ない
elseif a == 1 then
    a = 101         -- ここに来る
else
    a = 102         -- ここには来ない
end
x = a               -- x:101
```

#### while

**`while` 式 `do` ブロック `end`**

**式**の結果が真である間、**`do`ブロック**を繰り返し実行します。
```
a = 0
while a < 10 do
    a = a + 1
end
x = a           -- x:10
```

#### repeat

**`repeat` ブロック `until` 式**

最初に**`repeat`ブロック**を実行した後、**式**の結果が偽である間、**`repeat`ブロック**を繰り返し実行します。
**`repeat`ブロック**は必ず１回以上実行されます。
```
a = 0
repeat
    a = a + 1
until a >= 10
x = a           -- x:10
```

#### goto

**`::`ラベル名`::`**

**`goto` ラベル名**

`goto`文は制御を**ラベル**へ移動させます。
```
a = 1
goto foo        -- ラベル foo へジャンプ
a = 2           -- ここには来ない

::foo::         -- ラベル foo
x = a           -- x:1
```

#### break

`break`文はそれを囲んでいる最も内側の`while`、`repeat`、`for`ループの実行を終了し、制御をループブロックの次へ移動します。

#### return

`return`文は関数から値を返すために使います。カンマ`,`区切りで複数の値を返すことができます。
**ブロックの最後にしか記述出来ない**ことに注意してください。ブロックの途中に記述したい場合は、そのためのブロックで囲みます。
```
function foo()
    a = 0
    if a == 0 then
        a = a + 1
        return a        -- ここはブロックの最後
    end
    do return 2, 3 end  -- return するためのブロック
    return 7, 8, 9      -- ここはブロックの最後
end
```

#### 数値for

**`for` ループ変数 `=` 式1 `,` 式2 [`,` 式3] `do` ブロック `end`**

**ループ変数**が**式1**の値から始まり、**式3**の値づつ増えながら、**式2**の値を超えない間、**`do`ブロック**を繰り返し実行します。
**式1**、**式2**、**式3**はループが始まる前に一度だけ計算されます。
**式3**を省略すると`1`が使われます。
**ループ変数**はループ内でのローカル変数です。
```
a = 0
for i = 1, 4 do     -- i:1,2,3,4
    a = a + i
end
x = a               -- x:10

b = 0
for i = 0, 10, 3 do -- i:0,3,6,9
    b = b + i
end
x = b               -- x:18
```

#### 汎用for

**`for` キー変数`,`値変数 `in ipairs(` テーブル `) do` ブロック `end`**

テーブルについて**キー変数**と**値変数**にキーと値を設定しながら、最初のnil値まで**`do`ブロック**を繰り返し実行します。
`ipairs`は基本ライブラリの関数で、テーブルが配列の場合にこれを使います。インデックスの順番通りにテーブルを巡回できます。
```
t = { "H","e", "l", "l", "o" }
is = 0
vs = ""
for i, v in ipairs(t) do
    is = is + i     -- i:1,2,3,4,5
    vs = vs..v      -- v:"H","e", "l", "l", "o"
end
x = is              -- x:15
y = vs              -- y:"Hello"
```

**`for` キー変数`,`値変数 `in pairs(` テーブル `) do` ブロック `end`**

テーブルについて**キー変数**と**値変数**にキーと値を設定しながら、最初のnil値まで**`do`ブロック**を繰り返し実行します。
`pairs`は基本ライブラリの関数で、テーブルが配列でない場合にこれを使います。キーが数値でない項目も含めて巡回できます。
```
t = { a = 1, b = 2, c = 3 }
is = ""
vs = 0
for i, v in pairs(t) do
    is = is..i      -- i:"a","b","c"
    vs = vs + v     -- v:1,2,3
end
x = is              -- x:"abc"
y = vs              -- y:6
```

### 文としての関数呼び出し

**プレフィックス式 `(` [式リスト] `)`**

**関数**を呼び出す際、**引数**（ひきすう）と呼ばれるくつかの値を渡す事ができます。**式リスト**（カンマ`,`区切り）部分が引数のリストです。
関数からは戻り値を取得することもできまが、詳しくは [関数呼び出し](#関数呼び出し) で説明します。
```
f(3, 5 + 1, "foo")  -- 関数 f の呼び出し
```

### ローカル宣言

**`local` 変数リスト [`=` 式リスト]**

ローカル変数はどこでも宣言出来ます。宣言には初期値の [代入](#代入) をつけることも出来ます。
ローカル変数の可視性のルールについては [可視性ルール](#可視性ルール) で説明します。
```
local a             -- a:nil
local i, j, k = 1   -- i:1, j:nil, k:nil
local x = 1, 2, 3   -- x:1
```

---

## 式

基本的な式には以下のものがあります。

- [変数](#変数)、[関数呼び出し](#関数呼び出し)、`(`式`)`
- `nil`、`false`、`true`
- [数値リテラル](#字句)（`25`とか`3.14`とか）
- [文字列リテラル](#字句)（`"foo"`とか）
- [関数定義](#関数定義)
- [テーブルコンストラクタ](#テーブルコンストラクタ)
- `...`（可変長引数式）
- 二項演算（`2 + 7`とか`a >= b`とか）
- 単項演算（`-3`とか`#t`とか）

**二項演算**とは、2つの引数をとる演算のことを言い、[算術演算子](#算術演算子)、[ビット演算子](#ビット演算子)、[関係演算子](#関係演算子)、[論理演算子](#論理演算子)、[連結演算子](#連結)があります。
**単項演算**とは、1つの引数をとる演算のことを言い、[単項マイナス](#算術演算子)、[単項ビット否定](#ビット演算子)、[単項論理 not](#論理演算子)、[単項長さ演算子](#長さ演算子)があります。

関数呼び出しと可変長引数式は複数の値を返す場合があります。[関数呼び出しが文として使われた](#文としての関数呼び出し)場合、その戻り値リストはゼロ個の要素に調節されます。式を式リストの最後または唯一の要素として使った場合(式を括弧で囲った場合を除き)、値の個数は調節されませんが、それ以外の場合は戻り値は1個の値（最初のひとつ、なければ`nil`）に調節されます。
```
f()                -- 戻り値は0個に調節される
g(f(), x)          -- f()の戻り値は1個に調節される
g(x, f())          -- gは、xに加え、f()からの戻り値をすべて受け取りる
a,b,c = f(), x     -- f()の戻り値は1個に調節される (cはnilになる)
a,b = ...          -- aは可変長引数の最初の値を受け取り、
                   -- bは2番目の値を受け取る
                   -- (aもbも、対応する値がなければnilを受け取る)

a,b,c = x, f()     -- f()の戻り値は2個に調節される
a,b,c = f()        -- f()の戻り値は3個に調節される
return f()         -- f()の戻り値をすべて返す
return ...         -- 受け取った可変長引数をすべて返す
return x,y,f()     -- x、y、およびf()のすべての戻り値を返す
{f()}              -- f()のすべての戻り値を持つリストを作る
{...}              -- すべての可変長引数を持つリストを作る
{f(), nil}         -- f()の戻り値は1個に調節される
```
括弧`(` `)`で囲まれた式は常に1個だけの値になります。例えば関数`f`が複数の値を返す場合でも、`(f())`は必ず1個の値（最初のひとつ、なければ`nil`）となります。

### 算術演算子

計算を行うことを**演算**と言い、演算を表す記号のことを**演算子**と言います。
**算術演算子**とは、加算や減算などの普通の数値演算を行う演算子のことで、以下のものがあります。

- `+` : 加算
- `-` : 減算
- `*` : 乗算
- `/` : 浮動小数点数除算
- `//` : 切り捨て除算
- `%` : 剰余
- `^` : 累乗
- `-` : 単項マイナス（独立した`-3`とかのマイナス）

**浮動小数点**とは、コンピュータが実数（小数部を含む数値）を表す際の表現方法のことで、**浮動小数点数**とは浮動小数点で表現された数値のことです。
累乗と浮動小数点数除算以外の場合

- 引数（演算子に渡される値）が全て整数なら、演算は整数で行われ、結果も整数になります。
- 引数が実数や[数値に変換可能な文字列](#強制型変換)を含むなら、それらは浮動小数点数に変換され、結果も浮動小数点数になります。

累乗`^`と浮動小数点数除算`/`では、引数は常に浮動小数点数に変換され、結果も浮動小数点数になります。
切り捨て除算`//`の結果は、除算した結果の小数部を切り捨て（商を負の無限大に向かって丸め）たものです。
剰余`%`の結果は、切り捨て除算の余りです。
```
x = 3 ^ 3       -- x:27
x = 3.6 ^ 2.4   -- x:21.633460842026
x = 9 / 4       -- x:2.25
x = 9 / 2.5     -- x:3.6
x = 9 // 4      -- x:2
x = 9.3 // 4    -- x:2.0
x = 9 % 4       -- x:1
x = 9 % 4.3     -- x:0.4
```

### ビット演算子

**ビット演算子**とは、整数をビット列とみなし、ビット単位の演算を行う演算子です。

- `&` : ビットごとの論理積（左右の値の両方が`1`なら`1`、それ以外なら`0`を返す）
- `|` : ビットごとの論理和（左右の値のうち、一方もしくは両方が`1`なら`1`、それ以外なら`0`を返す）
- `~` : ビットごとの排他的論理和（左右の値が違えば`1`、同じなら`0`を返す）
- `>>` : 右シフト（左の値の全ビット列を、右の値を変位としてその分右にずらす）
- `<<` : 左シフト（左の値の全ビット列を、右の値を変位としてその分左にずらす）
- `~` : 単項ビットごとの否定（右の値の全ビットを反転する）

ビット演算子はすべて、引数を[整数に変換](#強制型変換)し、その整数の全ビットを演算し、結果を整数で返します。
右シフトと左シフトは両方とも、空いたビットをゼロで埋めます。変位に負の値を指定すると逆方向にシフトします。変位の絶対値が整数のビット数以上であれば結果はゼロになります（すべてのビットが追い出されます）。
```
x = 9 & 10      -- x:8  .. 1001 & 1010 -> 1000
x = 9 | 10      -- x:11 .. 1001 | 1010 -> 1011
x = 9 ~ 10      -- x:3  .. 1001 ~ 1010 -> 0011
x = 5 >> 2      -- x:1  .. 0101 -> 0010 -> 0001
x = 5 << 2      -- x:20 .. 0101 -> 1010 -> 10100
```

### 強制型変換

整数と浮動小数点数の混ざった算術演算を行う場合、以下の場合を除き、整数の引数は浮動小数点数に変換されます。

- ビット演算では浮動小数点数の引数は常に整数に変換されます。
- 累乗と浮動小数点数除算では整数の引数は常に浮動小数点数に変換されます。

整数から浮動小数点数への変換は必ず成功しますが、浮動小数点数から整数への変換は（端数があったり範囲外だったりすると）失敗する可能性があります。
数値と文字列の間でも、そこで期待される引数の型に応じて変換が行われます。
```
x = 3 + 4       -- x:7      .. 3 + 4 -> 7
x = 3 + 4.0     -- x:7.0    .. 3.0 + 4.0 -> 7.0
x = 5 / 2       -- x:2.5    .. 5.0 / 2.0 -> 2.5
x = 3 ^ 3       -- x:27.0   .. 3.0 ^ 3.0 -> 27.0
x = 6.0 | 1.0   -- x:7      .. 6 | 1 -> 7
x = 6.0 | 1.1   -- Error!! at 1.1
x = "foo"..8    -- x:foo8   .. "foo".."8" -> "foo8"
x = 5 + "3"     -- x:8.0    .. 5 + 3.0 -> 8.0
```

### 関係演算子

**関係演算子**は２つの引数をとり、それらの関係が演算子の意味する関係になっているかどうかを`false`か`true`で返します。

- `==` : 左の値と右の値が等しい
- `~=` : 左の値と右の値が等しくない
- `<` : 左の値が右の値より小さい
- `>` : 左の値が右の値より大きい
- `<=` : 左の値が右の値より小さい、または等しい
- `>=` : 左の値が右の値より大きい、または等しい

`==`（**等値比較**）は、引数の型が同じで、かつ、引数の値が等しい場合は`true`、それ以外の場合は`false`を返します。
引数の型が関数、テーブル、ユーザーデータ、スレッドの場合は、2つのオブジェクトが同じオブジェクト（参照先が同じ）である場合に等しいとみなされます。（関数がクロージャの場合、厳密にはもうすこし複雑です）
`==`は、文字列と数値の間で自動的な型変換は行いません。 そのため`"0"==0`は`false`に評価され、`t[0]`と`t["0"]`はテーブルの異なるエントリを指します。
`~=`は`==`の結果の`false`/`true`を反対にした意味になります。
`<`、`>`、`<=`、`>=`（**順序演算子**）は、引数が両方とも数値、もしくは両方とも文字列でなければ、通常は失敗します。（メタメソッドを利用するとこの動作をカスタマイズできます）
```
x = 3 == 3      -- x:true
x = 3 ~= 3      -- x:false
x = 5 < 8       -- x:true
x = "6" == 6    -- x:false

a = {1, 2, 3}
b = {1, 2, 3}
x = a == a      -- x:true
x = a == b      -- x:false
```

### 論理演算子

**論理演算子**には`and`、`or`、`not`があります。[制御構造](#制御構造)と同様に、すべての論理演算子は`false`と`nil`を偽とみなし、それ以外のすべてを真とみなします。

`not`（**否定演算子**）は右に引数を1つとり、引数の真偽を反転して、必ず`false`か`true`を返します。
`and`（**論理積演算子**）は引数を2つとり、左の引数が`false`か`nil`であればその値を返し、そうでなければ右の引数を返します。
`or`（**論理和演算子**）は引数を2つとり、左の引数が`nil`でも`false`でもなければその値を返し、そうでなければ右の引数を返します。

`and`と`or`は両方とも、**左の引数を返すことになった場合、右の引数を評価（式を計算したり関数呼び出しを行ったり）しません。**
```
x = not 10              -- x:false
x = not nil             -- x:true
x = 10 or 20            -- x:10
x = 10 or error()       -- x:10     .. error() is not called
x = nil or "a"          -- x:"a"
x = nil and 10          -- x:nil
x = false and error()   -- x:false  .. error() is not called
x = false and nil       -- x:false
x = false or nil        -- x:nil
x = 10 and 20           -- x:20
```

### 連結

`..`（**文字列連結演算子**）は2つの引数をとり、引数が両方とも文字列か数値であれば、[文字列に変換](#強制型変換)し、それらを連結した結果を返します。文字列でも数値でもない引数がある場合、通常は失敗します。（メタメソッドを利用するとこの動作をカスタマイズできます）
```
x = "foo" .. "bar"      -- x:"foobar"
x = "foo" .. "56"       -- x:"foo56"
x = "3.14" .. "159"     -- x:"3.14159"
```

### 長さ演算子

`#`（長さ演算子）は右に1つの引数をとり、その長さを返します。
引数が文字列の場合、長さはそのバイト数(つまり、それぞれの文字が1バイトだとしたときの、文字列の長さ)です。
引数がテーブルの場合、そのテーブルが**シーケンス**であれば長さはその要素数です。（テーブルがシーケンスでない場合について、ここでは説明しません）
**シーケンス**とは、空のテーブル`{}`を含む、インデックスが`1`から始まる連続する自然数だけ（途中に値の抜けがない）であるテーブルのことを言います。`{}`や`{10, 20, 30, 40}`はシーケンスですが、`{10, 20, nil, 40}`や`{nil, 20, 30, 40}`はシーケンスではありません。
（文字列以外の値については、メタメソッドを利用すると`#`の動作をカスタマイズできます）
```
x = #""                 -- x:0
x = #"foo"              -- x:3
x = #{}                 -- x:0
x = #{5, "a", 9, "b"}   -- x:4
```

### 優先順位

複数の演算が並んだ場合、どの演算を先に行うかについては、**演算子の優先順位**で決まります。
以下の表において、より上にあるほど優先順位が高いことを意味しています。

- `^`
- 単項演算子(`not` `#` `-` `~`)
- `*` `/` `//` `%`
- `+` `-`
- `..`
- `<<` `>>`
- `&`
- `~`
- `|`
- `<` `>` `<=` `>=` `~=` `==`
- `and`
- `or`

一般的な数式と同様に、括弧`(` `)`を使って式の優先度を変えることができます。
連結演算子`..`と累乗演算子`^`は**右結合**です。それ以外の**二項演算子**はすべて**左結合**です。
**単項演算子**とは、1つの引数をとる演算子のことを言います。同様に、2つの引数をとる演算子のことを**二項演算子**と言います。
**左結合**とは、優先順位に差がない演算と並んだ場合、左の演算を優先する性質のことを言います。同様に、右の演算を優先する性質のことを**右結合**と言います。
```
x = 1 + 2 - 3 + 4       -- x:4      .. ((1 + 2) - 3) + 4
x = 1 + 2 - 3 * 4       -- x:-9     .. (1 + 2) - (3 * 4)
x = 1 + (2 - 3) * 4     -- x:-3     .. 1 + ((2 - 3) * 4)
x = 1 > 2 + 3 or 4 < 5  -- x:true   .. (1 > (2 + 3)) or (4 < 5)
x = 2 ^ 2 ^ 3           -- x:256.0  .. 2 ^ (2 ^ 3)
```

### テーブルコンストラクタ

**テーブルコンストラクタ**はテーブルを作成する式のことで、評価されるたびに新しいテーブルが作成されます。
空のテーブルを作成したり、テーブルを作成していくつかのフィールドを初期化したりでき、以下のように記述します。

**`{` [フィールドリスト] `}`**

**フィールドリスト**はフィールドを`,`または`;`区切りで並べたもので、以下の3つの記述形式があります。

**`[` 式1 `] =` 式2**

この形式では、キーに **式1**、値に **式2** を持つエントリを、その新しいテーブルに追加します。

**名前 `=` 式**

この形式でのフィールドは、**`[ "`名前`" ] =` 式** と同等です。

**式**

この形式でのフィールドは、**`[` i `] =` 式** と同等です。 ただし **i** は1から始まる連番の整数です。他の形式のフィールドは、この連番に影響しません。例えば、

```
a = { [f(1)] = g; "x", "y"; x = 1, f(x), [30] = 23; 45 }
```
これは以下と同等です。
```
do
    local t = {}
    t[f(1)] = g
    t[1] = "x"      -- 最初の式
    t[2] = "y"      -- 2番目の式
    t.x = 1         -- t["x"] = 1
    t[3] = f(x)     -- 3番目の式
    t[30] = 23
    t[4] = 45       -- 4番目の式
    a = t
end
```

### 関数呼び出し

Luaの関数呼び出しは、以下のように記述します。

**プレフィックス式 `(` [式リスト] `)`**

**プレフィックス式**が関数を表し、**式リスト**が引数を表します。
関数呼び出しでは、まず**プレフィックス式**と**式リスト**が評価されます。**プレフィックス式**の値が関数型であれば、その関数が指定された引数で呼ばれます。そうでなければ、通常は失敗します。（メタメソッドを利用するとこの動作をカスタマイズできます）
**式リスト**はカンマ`,`区切りの式のリストで、全ての式は呼び出し前に評価されます。

### 関数定義

**関数定義は実行可能な式であり、関数型の値を持ちます。**基本的には以下のように記述します。

**`function (` [パラメータリスト] `)` ブロック `end`**

後で呼び出せるように、通常、定義した関数をグローバル変数やローカル変数に代入しておくでしょう。例えば引数なしの関数`f`を定義する場合、

**`f = function ()` ブロック `end`**

**`local f = function ()` ブロック `end`**

のような記述になりますが、簡単にするため以下のように記述することもできます。（こちらのほうがより一般的です）

**`function f ()` ブロック `end`**

**`local function f ()` ブロック `end`**

**パラメータリスト**はカンマ`,`区切りの変数名のリストで、関数呼び出しの引数の値で初期化されたローカル変数となります。
```
function f(a, b) end
function r() return 1,2,3 end

f(3)            -- a:3, b:nil
f(3, 4)         -- a:3, b:4
f(3, 4, 5)      -- a:3, b:4
f(r(), 10)      -- a:1, b:10
f(r())          -- a:1, b:2
```

戻り値は [return](#return) 文を使って返します。 制御が`return`文に出会わず関数の最後に達した場合、関数は戻り値なしでリターンします。

---

## 可視性ルール

ある名前（識別子）を参照できる範囲のことを**スコープ**と言い、ローカル変数はそのスコープ外からは参照できません（見えない、とも言います）。
ローカル変数のスコープは、その宣言の次の文から、その宣言を含む最も内側のブロックが終わるまでです。
任意のブロックで囲むことによって、ローカル変数のスコープを制限することができます。以下の例を考えてみてください。
```
a = 10                  -- グローバル変数 a
do                      -- 新しいブロック
    local a = a             -- 新しいローカル変数
    x = a                   -- x:10
    a = a + 1
    do                      -- 別の新しいブロック
        local a = a + 1         -- 別の新しいローカル変数 a
        x = a                   -- x:12
    end
    x = a                   -- x:11
end
x = a                   -- x:10, aはグローバル変数
```
`local a = a` のような宣言の場合、右辺の`a`は外側の変数を参照することに注意してください。いま宣言している新しい`a`はまだスコープに入っていないためです。

ローカル変数は、そのスコープ内で定義した関数から自由にアクセスできます。このように、関数の外側のローカル変数にアクセスする関数のことを**クロージャ**と言います。
`local`文を実行するたびに新しいローカル変数が定義されることに注意してください。以下の例を考えてみてください。
```
t = {}
local a = 0
for i = 1, 3 do
    local b = 0
    t[i] = function () a = a + 10; b = b + 1; return a + b end
end
x = t[1]()      -- x:11
x = t[2]()      -- x:21
x = t[3]()      -- x:31
```
このループはクロージャを3個作成します。これらのクロージャは、`a`は同じものを共有していますが、`b`はそれぞれ別々のものを持っています。

---

## 標準ライブラリ

**標準ライブラリ**とは、言語をより便利にする機能や、言語だけでは実装出来なかったり実装出来ても遅くなってしまう機能など、一般的に必要になりそうな機能を提供するものです。
Luaには以下の標準ライブラリがあります。

- [基本機能](lua_stdlib.md#基本機能)
- [コルーチン操作](lua_stdlib.md#コルーチン操作)
- パッケージ
- [文字列操作](lua_stdlib.md#文字列操作)
- 基本的なUTF-8のサポート
- [テーブル操作](lua_stdlib.md#テーブル操作)
- [数学関数](lua_stdlib.md#数学関数)
- 入出力
- OS機能
- デバッグ機能

基本機能ライブラリとパッケージライブラリを除き、各ライブラリの機能は、そのライブラリのテーブルに格納されています。
詳細は [Lua 5.3 標準ライブラリ](lua_stdlib.md) にあります。
